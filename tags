!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Args	Gamma.h	/^    std::vector<std::string> Args;$/;"	m	class:PrototypeAST
Args	Gamma.h	/^    std::vector<std::unique_ptr<ExprAST>> Args;$/;"	m	class:CallExprAST
BinaryExprAST	Gamma.h	/^    BinaryExprAST(int op,std::unique_ptr<ExprAST>LHS,std::unique_ptr<ExprAST>RHS)$/;"	f	class:BinaryExprAST
BinaryExprAST	Gamma.h	/^class BinaryExprAST : public ExprAST{$/;"	c
BinopPrecedence	LLparser.cpp	/^std::map<int,int>BinopPrecedence;$/;"	v
Body	Gamma.h	/^    std::unique_ptr<ExprAST> Start, End, Step, Body;$/;"	m	class:ForExprAST
Bodys	Gamma.h	/^    std::vector<std::unique_ptr<ExprAST>>Bodys;$/;"	m	class:FunctionAST
CallExprAST	Gamma.h	/^    CallExprAST(const std::string &Callee,std::vector<std::unique_ptr<ExprAST>>args)$/;"	f	class:CallExprAST
CallExprAST	Gamma.h	/^class CallExprAST : public ExprAST{$/;"	c
Callee	Gamma.h	/^    std::string Callee;$/;"	m	class:CallExprAST
Cond	Gamma.h	/^    std::unique_ptr<ExprAST> Cond,Then,Else;$/;"	m	class:IfExprAST
CreateEntryBlockAlloca	LLparser.cpp	/^llvm::AllocaInst *CreateEntryBlockAlloca(llvm::Function *TheFunction,const std::string &VarName){$/;"	f
Driver	LLparser.cpp	/^void Driver(){$/;"	f
Else	Gamma.h	/^    std::unique_ptr<ExprAST> Cond,Then,Else;$/;"	m	class:IfExprAST
End	Gamma.h	/^    std::unique_ptr<ExprAST> Start, End, Step, Body;$/;"	m	class:ForExprAST
ExprAST	Gamma.h	/^class ExprAST{$/;"	c
ForExprAST	Gamma.h	/^  ForExprAST(const std::string &VarName, std::unique_ptr<ExprAST> Start,$/;"	f	class:ForExprAST
ForExprAST	Gamma.h	/^class ForExprAST : public ExprAST{$/;"	c
FunctionAST	Gamma.h	/^    FunctionAST(std::unique_ptr<PrototypeAST> proto, std::vector<std::unique_ptr<ExprAST>>bodys)$/;"	f	class:FunctionAST
FunctionAST	Gamma.h	/^class FunctionAST{$/;"	c
FunctionProtos	Gamma.cpp	/^std::map<std::string,std::unique_ptr<PrototypeAST>> FunctionProtos;$/;"	v
GetTokPrecedence	LLparser.cpp	/^int GetTokPrecedence(){$/;"	f
HandleDefinition	LLparser.cpp	/^void HandleDefinition(){$/;"	f
HandleTopLevelExpression	LLparser.cpp	/^void HandleTopLevelExpression(){$/;"	f
IfExprAST	Gamma.h	/^    IfExprAST(std::unique_ptr<ExprAST> Cond, std::unique_ptr<ExprAST> Then,std::unique_ptr<ExprAST> Else) : Cond(std::move(Cond)),Then(std::move(Then)),Else(std::move(Else)){}$/;"	f	class:IfExprAST
IfExprAST	Gamma.h	/^class IfExprAST : public ExprAST{$/;"	c
InitializeModuleAndPassManager	Gamma.cpp	/^void InitializeModuleAndPassManager(){$/;"	f
LHS	Gamma.h	/^    std::unique_ptr<ExprAST> LHS,RHS;$/;"	m	class:BinaryExprAST
LogError	LLparser.cpp	/^std::unique_ptr<ExprAST> LogError(const char *str){$/;"	f
LogErrorP	LLparser.cpp	/^std::unique_ptr<PrototypeAST> LogErrorP(const char *str){$/;"	f
LogErrorV	LLparser.cpp	/^llvm::Value *LogErrorV(const char *str){$/;"	f
Name	Gamma.h	/^    std::string Name;$/;"	m	class:PrototypeAST
Name	Gamma.h	/^    std::string Name;$/;"	m	class:VariableExprAST
NamedValues	Gamma.cpp	/^std::map<std::string,llvm::AllocaInst *> NamedValues;$/;"	v
NumberExprAST	Gamma.h	/^    NumberExprAST(int Val) : Val(Val){}$/;"	f	class:NumberExprAST
NumberExprAST	Gamma.h	/^class NumberExprAST:public ExprAST{$/;"	c
Op	Gamma.h	/^    int Op;$/;"	m	class:BinaryExprAST
ParseBinOpRHS	LLparser.cpp	/^std::unique_ptr<ExprAST>ParseBinOpRHS(int ExprPrec,std::unique_ptr<ExprAST> LHS){$/;"	f
ParseDefinition	LLparser.cpp	/^std::unique_ptr<FunctionAST>ParseDefinition(){$/;"	f
ParseExpression	LLparser.cpp	/^std::unique_ptr<ExprAST>ParseExpression(){$/;"	f
ParseForExpr	LLparser.cpp	/^std::unique_ptr<ExprAST> ParseForExpr(){$/;"	f
ParseIdentifierExpr	LLparser.cpp	/^std::unique_ptr<ExprAST>ParseIdentifierExpr(){$/;"	f
ParseIfExpr	LLparser.cpp	/^std::unique_ptr<ExprAST>ParseIfExpr(){$/;"	f
ParseNumberExpr	LLparser.cpp	/^std::unique_ptr<ExprAST>ParseNumberExpr(){$/;"	f
ParseParenExpr	LLparser.cpp	/^std::unique_ptr<ExprAST>ParseParenExpr(){$/;"	f
ParsePrimary	LLparser.cpp	/^std::unique_ptr<ExprAST> ParsePrimary(){$/;"	f
ParsePrototype	LLparser.cpp	/^std::unique_ptr<PrototypeAST>ParsePrototype(){$/;"	f
ParseTopLevelExpr	LLparser.cpp	/^std::unique_ptr<FunctionAST>ParseTopLevelExpr(){$/;"	f
Proto	Gamma.h	/^    std::unique_ptr<PrototypeAST>Proto;$/;"	m	class:FunctionAST
PrototypeAST	Gamma.h	/^    PrototypeAST(const std::string &name$/;"	f	class:PrototypeAST
PrototypeAST	Gamma.h	/^class PrototypeAST{$/;"	c
RHS	Gamma.h	/^    std::unique_ptr<ExprAST> LHS,RHS;$/;"	m	class:BinaryExprAST
Start	Gamma.h	/^    std::unique_ptr<ExprAST> Start, End, Step, Body;$/;"	m	class:ForExprAST
Step	Gamma.h	/^    std::unique_ptr<ExprAST> Start, End, Step, Body;$/;"	m	class:ForExprAST
Symbol_table	Gamma.cpp	/^symbol_table Symbol_table;$/;"	v
T_NULL	Gamma.h	/^    T_NULL = -1,T_void, T_int, T_char, T_return, T_if, T_else, T_for,T_def, \/\/ Keyword$/;"	e	enum:token_type
T_add	Gamma.h	/^    T_assign, T_add, T_sub, T_mul, T_div, T_mod, T_equal, T_notequal, T_cmpULT, T_cmpUGT,   \/\/ operation$/;"	e	enum:token_type
T_assign	Gamma.h	/^    T_assign, T_add, T_sub, T_mul, T_div, T_mod, T_equal, T_notequal, T_cmpULT, T_cmpUGT,   \/\/ operation$/;"	e	enum:token_type
T_char	Gamma.h	/^    T_NULL = -1,T_void, T_int, T_char, T_return, T_if, T_else, T_for,T_def, \/\/ Keyword$/;"	e	enum:token_type
T_cmpUGT	Gamma.h	/^    T_assign, T_add, T_sub, T_mul, T_div, T_mod, T_equal, T_notequal, T_cmpULT, T_cmpUGT,   \/\/ operation$/;"	e	enum:token_type
T_cmpULT	Gamma.h	/^    T_assign, T_add, T_sub, T_mul, T_div, T_mod, T_equal, T_notequal, T_cmpULT, T_cmpUGT,   \/\/ operation$/;"	e	enum:token_type
T_colon	Gamma.h	/^    T_colon$/;"	e	enum:token_type
T_const	Gamma.h	/^    T_const, T_variable, \/\/ const,variable 17$/;"	e	enum:token_type
T_def	Gamma.h	/^    T_NULL = -1,T_void, T_int, T_char, T_return, T_if, T_else, T_for,T_def, \/\/ Keyword$/;"	e	enum:token_type
T_div	Gamma.h	/^    T_assign, T_add, T_sub, T_mul, T_div, T_mod, T_equal, T_notequal, T_cmpULT, T_cmpUGT,   \/\/ operation$/;"	e	enum:token_type
T_else	Gamma.h	/^    T_NULL = -1,T_void, T_int, T_char, T_return, T_if, T_else, T_for,T_def, \/\/ Keyword$/;"	e	enum:token_type
T_eof	Gamma.h	/^    T_eof, \/\/ END of file$/;"	e	enum:token_type
T_equal	Gamma.h	/^    T_assign, T_add, T_sub, T_mul, T_div, T_mod, T_equal, T_notequal, T_cmpULT, T_cmpUGT,   \/\/ operation$/;"	e	enum:token_type
T_for	Gamma.h	/^    T_NULL = -1,T_void, T_int, T_char, T_return, T_if, T_else, T_for,T_def, \/\/ Keyword$/;"	e	enum:token_type
T_if	Gamma.h	/^    T_NULL = -1,T_void, T_int, T_char, T_return, T_if, T_else, T_for,T_def, \/\/ Keyword$/;"	e	enum:token_type
T_int	Gamma.h	/^    T_NULL = -1,T_void, T_int, T_char, T_return, T_if, T_else, T_for,T_def, \/\/ Keyword$/;"	e	enum:token_type
T_lbrace	Gamma.h	/^    T_lbrace, T_rbrace, T_lbracket, T_rbracket, T_lparen, T_rparen, \/\/ { , } , [ , ] , ( , )$/;"	e	enum:token_type
T_lbracket	Gamma.h	/^    T_lbrace, T_rbrace, T_lbracket, T_rbracket, T_lparen, T_rparen, \/\/ { , } , [ , ] , ( , )$/;"	e	enum:token_type
T_lparen	Gamma.h	/^    T_lbrace, T_rbrace, T_lbracket, T_rbracket, T_lparen, T_rparen, \/\/ { , } , [ , ] , ( , )$/;"	e	enum:token_type
T_mod	Gamma.h	/^    T_assign, T_add, T_sub, T_mul, T_div, T_mod, T_equal, T_notequal, T_cmpULT, T_cmpUGT,   \/\/ operation$/;"	e	enum:token_type
T_mul	Gamma.h	/^    T_assign, T_add, T_sub, T_mul, T_div, T_mod, T_equal, T_notequal, T_cmpULT, T_cmpUGT,   \/\/ operation$/;"	e	enum:token_type
T_notequal	Gamma.h	/^    T_assign, T_add, T_sub, T_mul, T_div, T_mod, T_equal, T_notequal, T_cmpULT, T_cmpUGT,   \/\/ operation$/;"	e	enum:token_type
T_peroid	Gamma.h	/^    T_peroid, \/\/ , $/;"	e	enum:token_type
T_rbrace	Gamma.h	/^    T_lbrace, T_rbrace, T_lbracket, T_rbracket, T_lparen, T_rparen, \/\/ { , } , [ , ] , ( , )$/;"	e	enum:token_type
T_rbracket	Gamma.h	/^    T_lbrace, T_rbrace, T_lbracket, T_rbracket, T_lparen, T_rparen, \/\/ { , } , [ , ] , ( , )$/;"	e	enum:token_type
T_return	Gamma.h	/^    T_NULL = -1,T_void, T_int, T_char, T_return, T_if, T_else, T_for,T_def, \/\/ Keyword$/;"	e	enum:token_type
T_rparen	Gamma.h	/^    T_lbrace, T_rbrace, T_lbracket, T_rbracket, T_lparen, T_rparen, \/\/ { , } , [ , ] , ( , )$/;"	e	enum:token_type
T_semicolon	Gamma.h	/^    T_semicolon, \/\/ ;$/;"	e	enum:token_type
T_sub	Gamma.h	/^    T_assign, T_add, T_sub, T_mul, T_div, T_mod, T_equal, T_notequal, T_cmpULT, T_cmpUGT,   \/\/ operation$/;"	e	enum:token_type
T_variable	Gamma.h	/^    T_const, T_variable, \/\/ const,variable 17$/;"	e	enum:token_type
T_void	Gamma.h	/^    T_NULL = -1,T_void, T_int, T_char, T_return, T_if, T_else, T_for,T_def, \/\/ Keyword$/;"	e	enum:token_type
TheContext	Gamma.cpp	/^llvm::LLVMContext TheContext;$/;"	v
TheFPM	Gamma.cpp	/^std::unique_ptr<llvm::legacy::FunctionPassManager> TheFPM;$/;"	v
TheJIT	Gamma.cpp	/^std::unique_ptr<llvm::orc::KaleidoscopeJIT> TheJIT;$/;"	v
TheModule	Gamma.cpp	/^std::unique_ptr<llvm::Module> TheModule;$/;"	v
Then	Gamma.h	/^    std::unique_ptr<ExprAST> Cond,Then,Else;$/;"	m	class:IfExprAST
Val	Gamma.h	/^    int Val;$/;"	m	class:NumberExprAST
VarName	Gamma.h	/^    std::string VarName;$/;"	m	class:ForExprAST
VariableExprAST	Gamma.h	/^    VariableExprAST(const std::string &Name) : Name(Name){}$/;"	f	class:VariableExprAST
VariableExprAST	Gamma.h	/^class VariableExprAST:public ExprAST{$/;"	c
buffer	lexer.cpp	/^std::string buffer;$/;"	v
buffer_cmp	lexer.cpp	/^int buffer_cmp(char *str) {$/;"	f
cnt	LLparser.cpp	/^int cnt = 1;$/;"	v
codegen	LLparser.cpp	/^llvm::Function *FunctionAST::codegen(){$/;"	f	class:FunctionAST
codegen	LLparser.cpp	/^llvm::Function *PrototypeAST::codegen(){$/;"	f	class:PrototypeAST
codegen	LLparser.cpp	/^llvm::Value *BinaryExprAST::codegen(){$/;"	f	class:BinaryExprAST
codegen	LLparser.cpp	/^llvm::Value *CallExprAST::codegen(){$/;"	f	class:CallExprAST
codegen	LLparser.cpp	/^llvm::Value *ForExprAST::codegen(){$/;"	f	class:ForExprAST
codegen	LLparser.cpp	/^llvm::Value *IfExprAST::codegen(){$/;"	f	class:IfExprAST
codegen	LLparser.cpp	/^llvm::Value *NumberExprAST::codegen(){$/;"	f	class:NumberExprAST
codegen	LLparser.cpp	/^llvm::Value *VariableExprAST::codegen(){$/;"	f	class:VariableExprAST
datatype	Gamma.h	/^    int datatype;$/;"	m	struct:symbol
getFunction	LLparser.cpp	/^llvm::Function *getFunction(std::string Name){$/;"	f
getName	Gamma.h	/^    const std::string &getName() const {return Name;}$/;"	f	class:VariableExprAST
getName	Gamma.h	/^    const std::string &getName() const{return Name;}$/;"	f	class:PrototypeAST
getNextToken	LLparser.cpp	/^void getNextToken(){$/;"	f
get_vector	Gamma.h	/^    std::vector<std::string> get_vector(){$/;"	f	class:symbol_table
head	lexer.cpp	/^struct token *head;$/;"	v	typeref:struct:token
idNname	Gamma.h	/^    char *idNname;$/;"	m	struct:symbol
initToken	lexer.cpp	/^void initToken() {$/;"	f
init_buffer	lexer.cpp	/^void init_buffer(){$/;"	f
insert	Gamma.h	/^    void insert(std::string str,int token_type){$/;"	f	class:symbol_table
insertToken	lexer.cpp	/^void insertToken(int value) {$/;"	f
isbraket	lexer.cpp	/^void isbraket(char ch) {$/;"	f
iskeyword	lexer.cpp	/^int iskeyword() {		\/\/ keyword search$/;"	f
isop	lexer.cpp	/^void isop(char aheadch,FILE *fp) {$/;"	f
iter	LLparser.cpp	/^std::vector<std::string>::iterator iter;$/;"	v
keyword	lexer.cpp	/^std::string keyword[] = {$/;"	v
lexer	lexer.cpp	/^void lexer(FILE *fp) {$/;"	f
lookahead	lexer.cpp	/^struct token *lookahead;$/;"	v	typeref:struct:token
lookup	Gamma.h	/^    int lookup(std::string str){$/;"	f	class:symbol_table
main	Gamma.cpp	/^int main(int argc,char *argv[]) {$/;"	f
match	LLparser.cpp	/^void match(int terminal) {$/;"	f
next	Gamma.h	/^    struct symbol *next;$/;"	m	struct:symbol	typeref:struct:symbol::symbol
next	Gamma.h	/^    struct token *next;$/;"	m	struct:token	typeref:struct:token::token
override	Gamma.h	/^    llvm::Value *codegen() override;    $/;"	m	class:BinaryExprAST
override	Gamma.h	/^    llvm::Value *codegen() override;$/;"	m	class:CallExprAST
override	Gamma.h	/^    llvm::Value *codegen() override;$/;"	m	class:ForExprAST
override	Gamma.h	/^    llvm::Value *codegen() override;$/;"	m	class:IfExprAST
override	Gamma.h	/^    llvm::Value *codegen() override;$/;"	m	class:NumberExprAST
override	Gamma.h	/^    llvm::Value *codegen() override;$/;"	m	class:VariableExprAST
parser_init	LLparser.cpp	/^void parser_init() {$/;"	f
printTokens	lexer.cpp	/^void printTokens() {$/;"	f
removeLastToken	lexer.cpp	/^void removeLastToken() {$/;"	f
sym_list	LLparser.cpp	/^std::vector<std::string> sym_list;$/;"	v
symbol	Gamma.h	/^struct symbol {$/;"	s
symbol_list	Gamma.h	/^    std::vector<std::string>symbol_list;$/;"	m	class:symbol_table
symbol_table	Gamma.h	/^class symbol_table{$/;"	c
symbol_tree	Gamma.h	/^    std::map<std::string,int>symbol_tree;$/;"	m	class:symbol_table
tail	lexer.cpp	/^struct token *tail;$/;"	v	typeref:struct:token
token	Gamma.h	/^struct token {$/;"	s
token_p	lexer.cpp	/^struct token *token_p;$/;"	v	typeref:struct:token
token_type	Gamma.h	/^    int token_type;$/;"	m	struct:token
token_type	Gamma.h	/^enum token_type {$/;"	g
~ExprAST	Gamma.h	/^    virtual ~ExprAST(){}$/;"	f	class:ExprAST
